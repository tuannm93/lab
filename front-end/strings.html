<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Strings</title>
    <style>
        @import url("https://fonts.googleapis.com/css2?family=Rubik:ital,wght@0,300..900;1,300..900&display=swap");

        body {
            background: #EEE;
            margin: 0;
            display: flex;
            min-height: 100vh;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        canvas {
            max-height: 100vh;
            max-width: 100vw;
            height: auto;
            width: auto;
            /*   border: 1px solid silver; */
        }

        #container {
            box-shadow: 0 0 20px rgba(0, 0, 0, .05);
            border: 1px solid rgba(0, 0, 0, .1);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }

        h1 {
            font-family: Rubik;
            font-size: 100px;
            font-weight: 800;
            line-height: 1em;
            position: absolute;
            color: #fff;
        }

    </style>
</head>
<body>
<div id="container"></div>
<script type="module">
    import {Pane} from "https://cdn.jsdelivr.net/npm/tweakpane@4.0.5/dist/tweakpane.min.js";
    import {
        lerp,
        getPointsForGridId,
        getEdgeIdsForGridId,
        getPointID,
        hash,
        smoothstep
    } from "https://codepen.io/shubniggurath/pen/OPyPdmm.js";

    console.clear();

    const CONFIG = {
        width: 400,
        height: 400,
        gridW: 100,
        gridH: 40,
        gravity: .2,
        damping: .99,
        iterationsPerFrame: 10,
        compressFactor: .2,
        stretchFactor: 1.1,
        pointRadius: 0,
        lineWidth: 3,
        mouseSize: 4000,
        mouseStrength: 4,
        contain: false,
        randomSolve: false,
        preset: ''
    };
    // --- PANE ---
    const pane = new Pane();
    const f1 = pane.addFolder({
        title: "Config",
        expanded: false
    });
    const f2 = pane.addFolder({
        title: "Simulation",
        expanded: false
    });
    f1.addBinding(CONFIG, "width");
    f1.addBinding(CONFIG, "height");
    f1.addBinding(CONFIG, "gridW", {
        step: 1,
        min: 2,
        max: 200,
    });
    f1.addBinding(CONFIG, "gridH", {
        step: 1,
        min: 2,
        max: 100,
    });
    f2.addBinding(CONFIG, "gravity", {
        step: .05,
        min: 0,
        max: 2,
    });
    f2.addBinding(CONFIG, "damping", {
        step: .001,
        min: .5,
        max: 1.02,
    });
    f2.addBinding(CONFIG, "iterationsPerFrame", {
        step: 1,
        min: 1,
        max: 20,
    });
    f2.addBinding(CONFIG, "stretchFactor", {
        step: .01,
        min: 1.0,
        max: 2.0,
        label: "Max Stretch"
    });
    f2.addBinding(CONFIG, "compressFactor", {
        step: .01,
        min: 0.1,
        max: 1.0,
        label: "Min Compress"
    });
    f2.addBinding(CONFIG, "pointRadius", {
        step: 1,
        min: 0,
        max: 10.0,
        label: "Point radius"
    });
    f2.addBinding(CONFIG, "lineWidth", {
        step: 1,
        min: 0,
        max: 10.0,
        label: "Line width"
    });
    f2.addBinding(CONFIG, "mouseSize", {
        step: 1,
        min: 100,
        max: 10000,
        label: "Mouse size"
    });
    f2.addBinding(CONFIG, "mouseStrength", {
        step: 1,
        min: 1,
        max: 10,
        label: "Mouse strength"
    });
    f2.addBinding(CONFIG, "contain", {
        label: "Contain in canvas"
    });
    f1.addButton({
        title: "Render",
    }).on("click", (ev) => {
        input.unbind();
        cancelAnimationFrame(rafID)
        main();
    });
    f2.on("change", (ev) => {
        const event = new CustomEvent("update", {
            detail: {
                compressFactor: CONFIG.compressFactor,
                stretchFactor: CONFIG.stretchFactor
            }
        });
        c.dispatchEvent(event);
    });
    window.addEventListener('resize', () => {
        if (c && c.width) {
            c.width = window.innerWidth;
            c.height = window.innerHeight;
        }
    })
    const preset = pane.addBinding(CONFIG, 'preset', {
        options: {
            none: '',
            hair: 'hair',
            streamers: 'streamers',
        },
    });
    preset.on("change", (ev) => {
        if (ev.value == 'hair') {
            CONFIG.width = 300;
            CONFIG.gridW = 200;
            CONFIG.lineWidth = 1;
        } else if (ev.value == 'streamers') {
            CONFIG.width = 300;
            CONFIG.gridW = 20;
            CONFIG.lineWidth = 10;
            CONFIG.gravity = .1;
            CONFIG.stretchFactor = 1;
            CONFIG.compressFactor = 1;
            CONFIG.lineWidth = 15;
            CONFIG.mouseSize = 10000;
            CONFIG.mouseStrength = 3;
        }

        input.unbind();
        cancelAnimationFrame(rafID)
        main();
    });

    let rafID, input, c;

    function main() {
        const {
            width,
            height,
            gridW,
            gridH,
            gravity,
            damping,
            iterationsPerFrame,
            compressFactor,
            stretchFactor
        } = CONFIG;
        const cellWidth = width / (gridW - 1), cellHeight = height / (gridH - 1);

        c = document.createElement('canvas');
        container.innerHTML = '';
        container.appendChild(c);
        c.width = window.innerWidth;
        c.height = window.innerHeight;
        const ctx = c.getContext('2d');
        ctx.lineCap = "square";
        ctx.miterLimit = 0;
        ctx.lineJoin = "round";

        const particles = [];
        const constraints = [], verticalConstraints = [], horizontalConstraints = [];
        const pinnedParticles = [];

        input = new Input({c, particles});

        const randomX = Math.floor(Math.random() * gridW)
        for (let i = 0; i < gridW; i++) {
            for (let j = 0; j < gridH; j++) {
                let x = i * cellWidth;
                let y = j * cellHeight;

                // if(i == randomX && j == gridH-1) {
                //   x += -100 + Math.random()*200;
                //   y -= height + Math.random() * height;
                // }

                const id = getPointID(j, i, gridH);

                // const pinned = (j == 0 || i == 0 || j == gridH-1 || i == gridW-1);
                const pinned = j === 0;
                const particle = new Particle({x, y, pinned, id})
                particles.push(particle);
                if (pinned) pinnedParticles.push(particle);
            }
        }
        for (let i = 0; i < gridW; i++) {
            for (let j = 0; j < gridH; j++) {
                const id = getPointID(j, i, gridH);
                const p = particles[id];

                // Horizontal constraint
                // if(i<gridW-1) {
                //   const rightP = particles[getPointID(j, i+1, gridH)];
                //   const constraint = new Constraint({p1: p, p2: rightP, length: cellWidth, id, compressFactor, stretchFactor})
                //   constraints.push();
                //   verticalConstraints.pi
                // }
                // Vertical constraint
                if (j < gridH - 1) {
                    const bottomP = particles[getPointID(j + 1, i, gridH)];
                    constraints.push(new Constraint({
                        p1: p,
                        p2: bottomP,
                        length: cellHeight,
                        id: id + gridW * gridH,
                        compressFactor,
                        stretchFactor
                    }));
                }
            }
        }

        function drawParticles() {
            ctx.fillStyle = '#63b3ed';
            ctx.strokeStyle = '#4299e1';
            particles.forEach(p => {
                ctx.beginPath();
                ctx.arc(...p.pos, CONFIG.pointRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            });
        }

        function drawConstraints() {
            ctx.strokeStyle = '#a0aec0';
            ctx.lineWidth = CONFIG.lineWidth;
            let y = 0;
            constraints.forEach(c => {
                const a = c.p1.pos.clone();
                const b = c.p2.pos.clone();
                y = a.y;
                if (y == 0) {
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(...c.p1.pos);
                }
                ctx.lineTo(...c.p2.pos);
            });
            ctx.stroke();
            // constraints.forEach(c => {
            //   const a = c.p1.pos.clone();
            //   const b = c.p2.pos.clone();
            //   ctx.beginPath();
            //   ctx.moveTo(...c.p1.pos);
            //   ctx.lineTo(...c.p2.pos);
            //   ctx.stroke();
            // });
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        let lastDelta = 0;

        function runloop(delta) {
            rafID = requestAnimationFrame(runloop);

            ctx.save();
            ctx.clearRect(0, 0, c.width, c.height);
            ctx.translate(c.width / 2 - width / 2, c.height / 2 - height / 2);

            particles.forEach(p => p.update(delta - lastDelta));
            lastDelta = delta;

            if (CONFIG.randomSolve) shuffleArray(constraints)
            for (let i = 0; i < iterationsPerFrame; i++) {
                for (let j = 0; j < constraints.length; j++) constraints[j].solve();
            }

            if (CONFIG.contain) particles.forEach(p => p.contain());

            drawConstraints();
            if (CONFIG.pointRadius > 0) drawParticles();

            ctx.restore();
        }

        rafID = requestAnimationFrame(runloop);
    }

    class Input {
        constructor({c, particles}) {
            this.c = c, this.particles = particles;
            this.mousePos = new Vec2();
            this.grabRadius = 20;
            this.grabbed;
            this.bind()
        }

        get rect() {
            const rect = this.c.getBoundingClientRect();
            rect.scale = rect.width / this.c.width;
            return rect;
        }

        pointerdown(e) {
            const rect = this.rect;
            this.mousePos.x = e.clientX - c.width / 2 + CONFIG.width / 2;
            this.mousePos.y = e.clientY - c.height / 2 + CONFIG.height / 2;

            for (const p of this.particles) {
                if (this.mousePos.subtractNew(p.pos).length < this.grabRadius) {
                    this.grabbedParticle = p;
                    // Temporarily pin the grabbed particle
                    this.grabbedParticle.originalPinnedState = this.grabbedParticle.pinned;
                    this.grabbedParticle.pinned = true;
                    break;
                }
            }
            if (!this.grabbedParticle) {
                this.pointerIsDown = true
            }
        }

        pointerup(e) {
            if (this.grabbedParticle) {
                // Restore the particle's original pinned state
                this.grabbedParticle.pinned = this.grabbedParticle.originalPinnedState;
                this.grabbedParticle = null;
            }
            this.pointerIsDown = false
        }

        pointermove(e) {
            const rect = this.rect;
            this.mousePos.x = e.clientX - c.width / 2 + CONFIG.width / 2;
            this.mousePos.y = e.clientY - c.height / 2 + CONFIG.height / 2;
            // this.mousePos.scale(1/rect.scale);


            if (this.grabbedParticle) {
                // Set the grabbed particle's position directly to the mouse position
                this.grabbedParticle.pos.reset(this.mousePos.x, this.mousePos.y);
                this.grabbedParticle.oldPos.reset(this.mousePos.x, this.mousePos.y); // Prevent "snapping back"
            }
            for (const p of this.particles) {
                const diff = this.mousePos.subtractNew(p.pos);
                const ls = diff.lengthSquared
                if (ls < CONFIG.mouseSize) {
                    const a = diff.angle - Math.PI;
                    const strength = smoothstep(CONFIG.mouseSize, -2000, ls) * CONFIG.mouseStrength / 300;

                    const force = new Vec2(Math.cos(a) * strength, Math.sin(a) * strength);
                    p.applyForce(force)
                }
            }
        }

        contextmenu(e) {
            e.preventDefault();
        }

        bind() {
            this.pointerdown = this.pointerdown.bind(this)
            this.pointerup = this.pointerup.bind(this)
            this.pointermove = this.pointermove.bind(this)
            this.contextmenu = this.contextmenu.bind(this)
            document.addEventListener('pointerdown', this.pointerdown)
            document.addEventListener('pointerup', this.pointerup)
            // document.addEventListener('pointerout', this.pointerup)
            document.addEventListener('pointermove', this.pointermove)
            document.addEventListener('contextmenu', this.contextmenu)
        }

        unbind() {
            console.log(this)
            document.removeEventListener('pointerdown', this.pointerdown)
            document.removeEventListener('pointerup', this.pointerup)
            // document.removeEventListener('pointerout', this.pointerup)
            document.removeEventListener('pointermove', this.pointermove)
            document.removeEventListener('contextmenu', this.contextmenu)
        }
    }

    class Vec2 {
        constructor(x = 0, y = 0) {
            this.reset(x, y)
        }

        get array() {
            return [this.x, this.y];
        }

        get lengthSquared() {
            return this.x ** 2 + this.y ** 2;
        }

        get length() {
            return Math.hypot(this.x, this.y);
        }

        get angle() {
            return Math.atan2(this.y, this.x);
        }

        zero() {
            this.reset(0, 0)
        }

        reset(x = 0, y = 0) {
            this.x = x;
            this.y = y;
        }

        clone() {
            return new Vec2(this.x, this.y);
        }

        add(v) {
            this.x += v.x;
            this.y += v.y;
            return this;
        }

        addNew(v) {
            return this.clone().add(v);
        }

        subtract(v) {
            this.x -= v.x;
            this.y -= v.y;
            return this;
        }

        subtractNew(v) {
            return this.clone().subtract(v);
        }

        multiply(v) {
            this.x *= v.x;
            this.y *= v.y;
            return this;
        }

        multiplyNew(v) {
            return this.clone().multiply(v);
        }

        scale(scalar) {
            this.x *= scalar;
            this.y *= scalar;
            return this;
        }

        scaleNew(scalar) {
            return this.clone().scale(scalar);
        }

        [Symbol.iterator]() {
            let values = this.array;
            let i = 0;
            return {
                next() {
                    if (i < values.length) {
                        let value = values[i];
                        i++;
                        return {value, done: false}
                    } else return {done: true}
                }
            }
        }
    }

    class Particle {
        constructor({x, y, pinned, id} = {}) {
            this.pos = new Vec2(x, y);
            this.oldPos = new Vec2(x, y);
            this.velocity = new Vec2()
            this.acceleration = new Vec2();
            this.pinned = pinned;
            this.id = id;
        }

        contain() {
            // return;
            if (this.pinned) return;
            const radius = 5;

            if (this.pos.x < radius) {
                this.pos.x = radius;
                this.oldPos.x = this.pos.x + Math.abs(this.oldPos.x - this.pos.x) * 0.8;
            } else if (this.pos.x > CONFIG.width - radius) {
                this.pos.x = CONFIG.width - radius;
                this.oldPos.x = this.pos.x - Math.abs(this.oldPos.x - this.pos.x) * 0.8;
            }
            if (this.pos.y < radius) {
                this.pos.y = radius;
                this.oldPos.y = this.pos.y + Math.abs(this.oldPos.y - this.pos.y) * 0.8;
            } else if (this.pos.y > CONFIG.height - radius) {
                this.pos.y = CONFIG.height - radius;
                this.oldPos.y = this.pos.y - Math.abs(this.oldPos.y - this.pos.y) * 0.8;
            }
        }

        update(delta) {
            if (this.pinned) {
                this.acceleration.zero();
                return;
            }

            // Calculate the velocity from the current and old positions
            this.velocity.reset(
                (this.pos.x - this.oldPos.x) * CONFIG.damping,
                (this.pos.y - this.oldPos.y) * CONFIG.damping
            );

            // Set the old position to the new
            this.oldPos.reset(...this.pos);

            const dd = delta ** 2;

            this.applyForce(new Vec2(0, CONFIG.gravity / dd))

            this.pos.x += this.velocity.x + this.acceleration.x * dd;
            this.pos.y += this.velocity.y + this.acceleration.y * dd;

            this.acceleration.reset();
        }

        applyForce(v) {
            this.acceleration.add(v);
        }
    }

    let tt = 0;

    class Constraint {
        constructor({p1, p2, length, id, compressFactor, stretchFactor}) {
            this.p1 = p1;
            this.p2 = p2;
            this.length = length;
            this.id = id;
            this.minLength = length * compressFactor;
            this.maxLength = length * stretchFactor;

            c.addEventListener("update", (e) => {
                this.minLength = this.length * e.detail.compressFactor;
                this.maxLength = this.length * e.detail.stretchFactor;
            })
        }

        solve() {
            const diff = this.p2.pos.subtractNew(this.p1.pos);
            const distance = diff.length;
            if (distance == 0) return;

            let targetLength = this.length;
            if (distance < this.minLength) targetLength = this.minLength;
            else if (distance > this.maxLength) targetLength = this.maxLength;
            else return;

            const difference = targetLength - distance;
            const percent = difference / distance / 2;

            const offset = diff.scaleNew(percent);

            if (!this.p1.pinned) this.p1.pos.subtract(offset)
            if (!this.p2.pinned) this.p2.pos.add(offset)
        }
    }

    setTimeout(() => main(), 500);
</script>
</body>
</html>