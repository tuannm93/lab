<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Morphing Superformula Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
        }

        body {
            overflow: hidden;
            background: #050508;
            color: #fff;
            font-family: 'Inter', sans-serif;
        }

        #scene-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        :root {
            --background-color: rgba(22, 22, 30, 0.5);
            --text-color: rgba(255, 255, 255, 0.95);
            --title-background-color: rgba(40, 40, 60, 0.6);
            --title-text-color: rgba(255, 255, 255, 0.95);
            --widget-color: rgba(60, 60, 80, 0.5);
            --hover-color: rgba(80, 80, 120, 0.6);
            --focus-color: rgba(100, 100, 150, 0.7);
            --number-color: #ff55aa;
            --string-color: #55aaff;
        }

        .energy-button {
            border-radius: 6px !important;
            background: linear-gradient(to right, rgba(255, 65, 108, 0.9), rgba(255, 75, 43, 0.9)) !important;
            color: white !important;
            font-weight: bold !important;
            font-size: 14px !important;
            box-shadow: 0 4px 15px rgba(255, 85, 170, 0.4) !important;
            transition: all 0.3s !important;
            width: 100% !important;
            height: 40px !important;
            margin-top: 15px !important;
            margin-bottom: 8px !important;
            cursor: pointer !important;
            border: 1px solid rgba(255, 255, 255, 0.2) !important;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3) !important;
            position: relative !important;
            overflow: hidden !important;
            backdrop-filter: blur(4px) !important;
        }

        .energy-button:before {
            content: '';
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            background: linear-gradient(45deg,
            rgba(255, 255, 255, 0.1) 0%,
            rgba(255, 255, 255, 0.5) 25%,
            rgba(255, 255, 255, 0.1) 50%,
            rgba(255, 255, 255, 0) 50%);
            z-index: 1;
            transform: translateX(-100%);
            transition: transform 0.6s;
        }

        .energy-button:hover {
            transform: translateY(-2px) !important;
            box-shadow: 0 8px 20px rgba(255, 75, 43, 0.6) !important;
        }

        .energy-button:hover:before {
            transform: translateX(100%);
        }

        .energy-button:active {
            transform: translateY(1px) !important;
        }

        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
    </style>
</head>
<body>
<div id="scene-container"></div>
<script type="module">
    import * as THREE from "https://esm.sh/three";
    import {OrbitControls} from "https://esm.sh/three/examples/jsm/controls/OrbitControls.js";
    import {EffectComposer} from "https://esm.sh/three/examples/jsm/postprocessing/EffectComposer.js";
    import {RenderPass} from "https://esm.sh/three/examples/jsm/postprocessing/RenderPass.js";
    import {UnrealBloomPass} from "https://esm.sh/three/examples/jsm/postprocessing/UnrealBloomPass.js";
    import GUI from "https://esm.sh/lil-gui";

    class SuperformulaWireframe {
        constructor() {
            this.presets = [
                {m1: 5, n11: 10, n12: 2, n13: 7, m2: 5, n21: 10, n22: 10, n23: 10},
                {m1: 2, n11: 1, n12: 4, n13: 8, m2: 8, n21: 1, n22: 1, n23: 4},
                {m1: 6, n11: 1, n12: 1, n13: 1, m2: 3, n21: 1, n22: 5, n23: 1},
                {m1: 12, n11: 15, n12: 8, n13: 8, m2: 12, n21: 8, n22: 4, n23: 15}
            ];

            this.presetOptions = {
                "Star Crystal": 0,
                "Ocean Creature": 1,
                "Spiral Galaxy": 2,
                "Quantum Form": 3
            };

            this.themes = {
                "Synthwave": {
                    colors: ["#ff1f5a", "#ff758a", "#1e3799", "#0984e3"],
                    burstColor: "#ffffff"
                },
                "Forest": {
                    colors: ["#38ef7d", "#11998e", "#ffe259", "#ffa751"],
                    burstColor: "#ffff99"
                },
                "Ocean": {
                    colors: ["#2193b0", "#38ef7d", "#00b4db", "#0083B0"],
                    burstColor: "#8cffff"
                },
                "Sunset": {
                    colors: ["#FF416C", "#FF4B2B", "#f5af19", "#f12711"],
                    burstColor: "#ffffa8"
                }
            };
            this.themeNames = Object.keys(this.themes);

            this.params = {
                preset: 0,
                morphDuration: 2.0,

                pulseSpeed: 1.0,
                pulseIntensity: 0.2,
                microAnimationIntensity: 0.15,
                colorTheme: "Sunset",

                burstSpeed: 0.8,
                burstDuration: 6.0,
                multiWave: true,

                bloomStrength: 1.4,
                bloomRadius: 0.5,
                bloomThreshold: 0.18
            };

            this.resolutionTheta = 100;
            this.resolutionPhi = 100;

            this.currentPresetParams = {...this.presets[this.params.preset]};
            this.targetPresetParams = {...this.presets[this.params.preset]};
            this.isMorphing = false;
            this.morphStartTime = 0;

            this.burstActive = 0.0;
            this.burstStartTime = -1.0;
            this.lastBurstTime = 0;

            this.superformula = (angle, m, n1, n2, n3, a = 1, b = 1) => {
                const term1 = Math.pow(Math.abs(Math.cos(m * angle / 4) / a), n2);
                const term2 = Math.pow(Math.abs(Math.sin(m * angle / 4) / b), n3);
                const sum = term1 + term2;
                if (sum === 0) return 0;
                return Math.pow(sum, -1 / n1);
            };

            this.init();
            this.setupGUI();
            this.animate();
        }

        init() {
            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            this.camera.position.set(0, 0, 2.5);
            this.camera.lookAt(0, 0, 0);

            this.renderer = new THREE.WebGLRenderer({antialias: true});
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
            this.renderer.toneMappingExposure = 1.0;
            this.container = document.getElementById("scene-container");
            this.container.appendChild(this.renderer.domElement);

            this.composer = new EffectComposer(this.renderer);
            this.composer.addPass(new RenderPass(this.scene, this.camera));

            this.bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                this.params.bloomStrength,
                this.params.bloomRadius,
                this.params.bloomThreshold
            );
            this.composer.addPass(this.bloomPass);

            this.controls = new OrbitControls(this.camera, this.renderer.domElement);
            this.controls.enableDamping = true;
            this.controls.dampingFactor = 0.05;
            this.controls.autoRotate = false;
            this.controls.minDistance = 1;

            this.clock = new THREE.Clock();

            this.createWireframe();
            this.updateWireframeGeometry();

            window.addEventListener("resize", () => this.onResize());

            this.container.addEventListener('click', (event) => {
                if (!this.isDragging) {
                    this.triggerBurst();
                }
            });

            this.container.addEventListener('mousedown', () => {
                this.isDragging = false;
            });
            this.container.addEventListener('mousemove', () => {
                if (this.isMouseDown) this.isDragging = true;
            });
            this.container.addEventListener('mouseup', () => {
                this.isMouseDown = false;
            });
            this.container.addEventListener('mousedown', () => {
                this.isMouseDown = true;
            });
        }

        triggerBurst() {
            const currentTime = this.clock.getElapsedTime();

            if (currentTime - this.lastBurstTime > 0.3) {
                this.burstActive = 1.0;
                this.burstStartTime = currentTime;
                this.lastBurstTime = currentTime;

                const burstButton = document.querySelector('.energy-button');
                if (burstButton) {
                    burstButton.style.boxShadow = '0 0 40px rgba(255, 175, 25, 0.9)';
                    burstButton.style.transform = 'scale(1.15)';

                    const theme = this.themes[this.params.colorTheme];
                    const colors = theme.colors;
                    burstButton.style.background = `linear-gradient(to right, ${colors[0]}, ${colors[2]})`;

                    setTimeout(() => {
                        burstButton.style.boxShadow = '0 0 30px rgba(255, 100, 75, 0.8)';
                        burstButton.style.transform = 'scale(1.1)';
                    }, 150);

                    setTimeout(() => {
                        burstButton.style.boxShadow = '0 0 20px rgba(245, 175, 25, 0.6)';
                        burstButton.style.transform = 'scale(1.05)';
                        burstButton.style.background = `linear-gradient(to right, ${colors[1]}, ${colors[3]})`;
                    }, 300);

                    setTimeout(() => {
                        burstButton.style.boxShadow = '0 8px 20px rgba(255, 75, 43, 0.6)';
                        burstButton.style.transform = '';
                        burstButton.style.background = 'linear-gradient(to right, rgba(255, 65, 108, 0.9), rgba(255, 75, 43, 0.9))';
                    }, 500);
                }

                if (this.wireframeMesh) {
                    const theme = this.themes[this.params.colorTheme];
                    const burstColor = theme.burstColor || "#ffffff";

                    this.wireframeMesh.material.uniforms.burstActive.value = this.burstActive;
                    this.wireframeMesh.material.uniforms.burstStartTime.value = this.burstStartTime;
                    this.wireframeMesh.material.uniforms.burstColor.value.set(burstColor);
                }
            }
        }

        createWireframe() {
            const geometry = new THREE.BufferGeometry();
            const resTheta = this.resolutionTheta;
            const resPhi = this.resolutionPhi;
            const vertexCount = (resTheta + 1) * (resPhi + 1);

            const positions = new Float32Array(vertexCount * 3);
            const colors = new Float32Array(vertexCount * 3);
            const indices = [];

            for (let i = 0; i < resTheta; i++) {
                for (let j = 0; j < resPhi; j++) {
                    const current = i * (resPhi + 1) + j;
                    const nextTheta = (i + 1) * (resPhi + 1) + j;
                    const nextPhi = current + 1;
                    indices.push(current, nextTheta);
                    indices.push(current, nextPhi);
                }
                indices.push(i * (resPhi + 1) + resPhi, (i + 1) * (resPhi + 1) + resPhi);
            }
            const lastRowStart = resTheta * (resPhi + 1);
            for (let j = 0; j < resPhi; j++) {
                indices.push(lastRowStart + j, lastRowStart + j + 1);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(new THREE.Uint32BufferAttribute(indices, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: {value: 0.0},
                    pulseSpeed: {value: this.params.pulseSpeed},
                    pulseIntensity: {value: this.params.pulseIntensity},
                    microAnimationIntensity: {value: this.params.microAnimationIntensity},
                    dashSize: {value: 0.1},
                    dashRatio: {value: 0.5},
                    burstActive: {value: this.burstActive},
                    burstStartTime: {value: this.burstStartTime},
                    burstSpeed: {value: this.params.burstSpeed},
                    burstDuration: {value: this.params.burstDuration},
                    burstColor: {value: new THREE.Color(this.themes[this.params.colorTheme].burstColor)},
                    multiWave: {value: this.params.multiWave ? 1.0 : 0.0},
                    morphProgress: {value: 0.0}
                },
                vertexShader: `
              uniform float time;
              uniform float pulseSpeed;
              uniform float pulseIntensity;
              uniform float microAnimationIntensity;
              uniform float morphProgress;

              varying vec3 vColor;
              varying vec3 vPos;
              varying float vLineDistance;

              void main() {
                  vColor = color;
                  vPos = position;

                  vLineDistance = length(position);

                  float pulse = sin(length(position) * 2.0 - time * pulseSpeed) * pulseIntensity;

                  float microAnim1 = sin(position.x * 8.0 + time * 3.0) * microAnimationIntensity;
                  float microAnim2 = cos(position.y * 9.0 + time * 2.7) * microAnimationIntensity;
                  float microAnim3 = sin(position.z * 7.0 + time * 3.3) * microAnimationIntensity;

                  vec3 microOffset = vec3(microAnim1, microAnim2, microAnim3);
                  vec3 pulseOffset = normalize(position) * pulse;

                  microOffset *= (1.0 + morphProgress * 3.0);

                  vec3 animatedPos = position + pulseOffset + microOffset;
                  gl_Position = projectionMatrix * modelViewMatrix * vec4(animatedPos, 1.0);
              }
          `,
                fragmentShader: `
              uniform float time;
              uniform float dashSize;
              uniform float dashRatio;
              uniform float burstActive;
              uniform float burstStartTime;
              uniform float burstSpeed;
              uniform float burstDuration;
              uniform vec3 burstColor;
              uniform float multiWave;

              varying vec3 vColor;
              varying vec3 vPos;
              varying float vLineDistance;

              void main() {
                  vec3 finalColor = vColor;
                  float finalIntensity = 1.0;

                  float totalSize = dashSize * (1.0 + dashRatio);
                  float patternPos = mod(vLineDistance + time * 0.2, totalSize);
                  float dashPart = step(patternPos, dashSize);

                  if (dashPart < 0.1) {
                      discard;
                  }

                  finalIntensity *= (1.0 + dashPart * 0.5);

                  if (burstActive > 0.5) {
                      float burstElapsed = max(0.0, time - burstStartTime);
                      if (burstElapsed < burstDuration) {
                          float distOrigin = length(vPos);
                          float progress = burstElapsed / burstDuration;

                          float baseSpeed = burstSpeed;
                          float mainRadius = burstElapsed * baseSpeed;
                          float mainThickness = 0.4 * (1.0 - 0.5 * progress);

                          float mainDist = abs(distOrigin - mainRadius);
                          float mainWave = 1.0 - smoothstep(0.0, mainThickness, mainDist);

                          float trailFactor = smoothstep(0.0, mainRadius, distOrigin) * (1.0 - smoothstep(mainRadius * 0.5, mainRadius, distOrigin));

                          float secondaryWave = 0.0;
                          float tertiaryWave = 0.0;

                          if (multiWave > 0.5) {
                              float secondaryRadius = burstElapsed * (baseSpeed * 1.5);
                              float secondaryThickness = 0.3 * (1.0 - 0.6 * progress);
                              float secondaryDist = abs(distOrigin - secondaryRadius);
                              secondaryWave = 1.0 - smoothstep(0.0, secondaryThickness, secondaryDist);
                              secondaryWave *= 0.7 * (1.0 - progress * 0.7);

                              float tertiaryRadius = burstElapsed * (baseSpeed * 0.7);
                              float tertiaryThickness = 0.25 * (1.0 - 0.4 * progress);
                              float tertiaryDist = abs(distOrigin - tertiaryRadius);
                              tertiaryWave = 1.0 - smoothstep(0.0, tertiaryThickness, tertiaryDist);
                              tertiaryWave *= 0.5 * (1.0 - progress * 0.5);
                          }

                          vec3 waveColorShift = burstColor;
                          if (secondaryWave > 0.01) {
                              waveColorShift = mix(burstColor, vec3(0.5, 0.8, 1.0), 0.3);
                          }
                          if (tertiaryWave > 0.01) {
                              waveColorShift = mix(burstColor, vec3(0.8, 0.5, 1.0), 0.3);
                          }

                          float combinedWave = max(max(mainWave, secondaryWave * 0.8), tertiaryWave * 0.6);
                          combinedWave = max(combinedWave, trailFactor * 0.4);

                          float timeFade = 1.0 - smoothstep(burstDuration * 0.6, burstDuration, burstElapsed);
                          combinedWave *= timeFade;

                          finalColor = mix(finalColor, waveColorShift, combinedWave * 0.8);
                          finalIntensity += combinedWave * 3.0;

                          float rippleFactor = sin(distOrigin * 10.0 - burstElapsed * 5.0) * 0.5 + 0.5;
                          rippleFactor *= smoothstep(0.0, mainRadius * 0.8, distOrigin) * (1.0 - smoothstep(mainRadius * 0.8, mainRadius, distOrigin));
                          rippleFactor *= 0.15 * timeFade;

                          finalIntensity += rippleFactor;
                      }
                  }

                  gl_FragColor = vec4(finalColor * finalIntensity, 1.0);
              }
          `,
                vertexColors: true
            });

            this.wireframeMesh = new THREE.LineSegments(geometry, material);
            this.scene.add(this.wireframeMesh);
        }

        updateWireframeGeometry() {
            if (!this.wireframeMesh) return;

            const geometry = this.wireframeMesh.geometry;
            const positions = geometry.attributes.position.array;
            const colors = geometry.attributes.color.array;

            const sfParams = this.isMorphing ? this.getInterpolatedParams() : this.currentPresetParams;
            const resTheta = this.resolutionTheta;
            const resPhi = this.resolutionPhi;

            const theme = this.themes[this.params.colorTheme];
            const themeColors = theme.colors.map(color => new THREE.Color(color));

            let vertexIndex = 0;
            for (let i = 0; i <= resTheta; i++) {
                const theta = THREE.MathUtils.mapLinear(i, 0, resTheta, -Math.PI / 2, Math.PI / 2);
                const r1 = this.superformula(theta, sfParams.m1, sfParams.n11, sfParams.n12, sfParams.n13);

                for (let j = 0; j <= resPhi; j++) {
                    const phi = THREE.MathUtils.mapLinear(j, 0, resPhi, -Math.PI, Math.PI);
                    const r2 = this.superformula(phi, sfParams.m2, sfParams.n21, sfParams.n22, sfParams.n23);

                    const x = r1 * Math.cos(theta) * r2 * Math.cos(phi);
                    const y = r1 * Math.sin(theta);
                    const z = r1 * Math.cos(theta) * r2 * Math.sin(phi);

                    positions[vertexIndex * 3 + 0] = x;
                    positions[vertexIndex * 3 + 1] = y;
                    positions[vertexIndex * 3 + 2] = z;

                    const colorMix = THREE.MathUtils.smoothstep(y, -1.5, 1.5);

                    const colorIndex1 = Math.floor(colorMix * (themeColors.length - 1));
                    const colorIndex2 = Math.min(colorIndex1 + 1, themeColors.length - 1);
                    const colorFraction = (colorMix * (themeColors.length - 1)) - colorIndex1;

                    const vertexColor = themeColors[colorIndex1].clone().lerp(
                        themeColors[colorIndex2], colorFraction
                    );

                    colors[vertexIndex * 3 + 0] = vertexColor.r;
                    colors[vertexIndex * 3 + 1] = vertexColor.g;
                    colors[vertexIndex * 3 + 2] = vertexColor.b;

                    vertexIndex++;
                }
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            geometry.computeBoundingSphere();
        }

        getInterpolatedParams() {
            const duration = Math.max(0.001, this.params.morphDuration);
            const elapsedTime = this.clock.getElapsedTime() - this.morphStartTime;
            const totalProgress = Math.min(1.0, elapsedTime / duration);

            if (this.wireframeMesh && this.wireframeMesh.material.uniforms.morphProgress) {
                const morphEffect = Math.sin(totalProgress * Math.PI);
                this.wireframeMesh.material.uniforms.morphProgress.value = morphEffect;
            }

            const interpolated = {};
            for (const key in this.currentPresetParams) {
                const factor = Math.sin(totalProgress * Math.PI / 2);
                interpolated[key] = THREE.MathUtils.lerp(
                    this.currentPresetParams[key],
                    this.targetPresetParams[key],
                    factor
                );
            }
            return interpolated;
        }

        startMorphing(targetPresetIndex) {
            const targetIndex = Number(targetPresetIndex);
            if (isNaN(targetIndex) || targetIndex < 0 || targetIndex >= this.presets.length) {
                console.error("Invalid target preset index:", targetPresetIndex);
                return;
            }

            if (!this.isMorphing) {
                this.currentPresetParams = {...this.presets[this.params.preset]};
            } else {
                this.currentPresetParams = this.getInterpolatedParams();
            }

            this.params.preset = targetIndex;
            this.targetPresetParams = {...this.presets[targetIndex]};

            this.isMorphing = true;
            this.morphStartTime = this.clock.getElapsedTime();
        }

        setupGUI() {
            const customStyles = document.createElement('style');
            customStyles.textContent = `
      .lil-gui {
          border-radius: 12px;
          width: 280px;
          font-family: 'Inter', sans-serif;
          backdrop-filter: blur(12px);
          border: 1px solid rgba(255, 255, 255, 0.15);
          box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
          overflow: hidden;
          opacity: 0.92;
          transition: opacity 0.3s;
          background: rgba(20, 20, 28, 0.5);
      }

      .lil-gui:hover {
          opacity: 0.98;
      }

      .lil-gui .title {
          border-radius: 10px 10px 0 0;
          font-weight: bold;
          letter-spacing: 0.5px;
          text-transform: uppercase;
          font-size: 11px;
          padding: 10px 12px;
          transition: background-color 0.3s;
          border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .lil-gui .controller {
          border-radius: 6px;
          margin: 4px 6px;
          padding: 6px 10px;
          background: rgba(60, 60, 80, 0.25);
          border: 1px solid rgba(255, 255, 255, 0.05);
          transition: all 0.2s;
      }

      .lil-gui .controller:hover {
          background-color: rgba(80, 80, 120, 0.35);
          border-color: rgba(255, 255, 255, 0.1);
      }

      .lil-gui .controller.color input[type="color"] {
          border-radius: 6px;
          border: 2px solid rgba(255, 255, 255, 0.2);
          width: 16px;
          height: 16px;
      }

      .lil-gui button {
          border-radius: 6px;
          background: linear-gradient(to right, rgba(60, 60, 100, 0.8), rgba(80, 80, 150, 0.8));
          border: 1px solid rgba(255, 255, 255, 0.1);
          transition: all 0.2s;
          box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      }

      .lil-gui button:hover {
          background: linear-gradient(to right, rgba(80, 80, 150, 0.9), rgba(100, 100, 200, 0.9));
          transform: translateY(-1px);
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }

      .lil-gui .controller select {
          background: rgba(40, 40, 60, 0.7);
          border: 1px solid rgba(255, 255, 255, 0.1);
          border-radius: 4px;
          padding: 3px 6px;
          color: white;
      }

      .lil-gui .folder > .title {
          background: rgba(60, 60, 100, 0.4);
      }

      .lil-gui.root {
          margin-top: 10px;
          margin-right: 10px;
      }
    `;
            document.head.appendChild(customStyles);

            this.gui = new GUI();

            const shapeFolder = this.gui.addFolder('Shape & Morphing');
            this.guiPresetController = shapeFolder.add(this.params, 'preset', this.presetOptions).name('Shape Preset').listen().onChange((value) => {
                this.startMorphing(value);
            });
            shapeFolder.add(this.params, 'morphDuration', 0.5, 5.0, 0.1).name('Morph Duration');

            const animFolder = this.gui.addFolder('Animation & Color');
            animFolder.add(this.params, 'pulseSpeed', 0, 2, 0.05).name('Pulse Speed').onChange((value) => {
                if (this.wireframeMesh) this.wireframeMesh.material.uniforms.pulseSpeed.value = value;
            });
            animFolder.add(this.params, 'pulseIntensity', 0, 0.5, 0.01).name('Pulse Intensity').onChange((value) => {
                if (this.wireframeMesh) this.wireframeMesh.material.uniforms.pulseIntensity.value = value;
            });
            animFolder.add(this.params, 'microAnimationIntensity', 0, 0.3, 0.01).name('Micro-Animations').onChange(value => {
                if (this.wireframeMesh) this.wireframeMesh.material.uniforms.microAnimationIntensity.value = value;
            });
            animFolder.add(this.params, 'colorTheme', this.themeNames).name('Color Theme').onChange(() => {
                this.updateWireframeGeometry();
                if (this.wireframeMesh && this.wireframeMesh.material.uniforms.burstColor) {
                    const themeColor = this.themes[this.params.colorTheme].burstColor || "#ffffff";
                    this.wireframeMesh.material.uniforms.burstColor.value.set(themeColor);
                }
            });

            const bloomFolder = this.gui.addFolder('Bloom Effect');
            bloomFolder.add(this.params, 'bloomStrength', 0, 3).name('Strength').onChange((value) => {
                this.bloomPass.strength = value;
            });
            bloomFolder.add(this.params, 'bloomRadius', 0, 2).name('Radius').onChange((value) => {
                this.bloomPass.radius = value;
            });
            bloomFolder.add(this.params, 'bloomThreshold', 0, 1).name('Threshold').onChange((value) => {
                this.bloomPass.threshold = value;
            });

            const burstFolder = this.gui.addFolder('Energy Burst');
            burstFolder.add(this.params, 'multiWave').name('Multi-Wave Effect').onChange(value => {
                if (this.wireframeMesh) {
                    this.wireframeMesh.material.uniforms.multiWave.value = value ? 1.0 : 0.0;
                }
            });

            const burstButton = document.createElement('button');
            burstButton.textContent = '✨ ENERGY BURST ✨';
            burstButton.className = 'energy-button';
            burstButton.onclick = () => this.triggerBurst();
            this.gui.domElement.appendChild(burstButton);

            shapeFolder.open();
            animFolder.open();
            burstFolder.open();
        }

        animate() {
            requestAnimationFrame(() => this.animate());
            const elapsedTime = this.clock.getElapsedTime();
            const delta = this.clock.getDelta();

            if (this.isMorphing) {
                const morphProgress = (elapsedTime - this.morphStartTime) / Math.max(0.001, this.params.morphDuration);
                if (morphProgress >= 1.0) {
                    this.isMorphing = false;
                    this.currentPresetParams = {...this.targetPresetParams};
                    this.updateWireframeGeometry();
                    if (this.guiPresetController) this.guiPresetController.updateDisplay();
                } else {
                    this.updateWireframeGeometry();
                }
            }

            if (this.wireframeMesh && this.wireframeMesh.material.uniforms) {
                this.wireframeMesh.material.uniforms.time.value = elapsedTime;
                this.wireframeMesh.material.uniforms.burstActive.value = this.burstActive;
                this.wireframeMesh.material.uniforms.burstStartTime.value = this.burstStartTime;

                if (this.burstActive > 0.5 && (elapsedTime - this.burstStartTime >= this.params.burstDuration)) {
                    this.burstActive = 0.0;
                    this.burstStartTime = -1.0;
                }
            }

            this.controls.update(delta);
            this.composer.render();
        }

        onResize() {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.composer.setSize(window.innerWidth, window.innerHeight);
        }
    }

    window.onload = () => {
        new SuperformulaWireframe();
    }
</script>
</body>
</html>