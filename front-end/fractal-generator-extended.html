<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Fractal Generator Extended</title>
    <style>
        body {
            margin: 0;
            background: #000;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
<script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.136.0/build/three.module.js'
    import {EffectComposer} from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js'
    import {RenderPass} from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js'
    import {UnrealBloomPass} from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js'
    import {OrbitControls} from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js'
    import {GUI} from 'https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.module.js'
    import anime from 'https://cdn.skypack.dev/animejs@3.2.1'

    const scene = new THREE.Scene()
    const camera = new THREE.OrthographicCamera(-500, 500, 500, -500, 0.1, 1000)
    camera.position.z = 5
    camera.lookAt(0, 0, 0)

    const renderer = new THREE.WebGLRenderer({antialias: true})
    renderer.setPixelRatio(window.devicePixelRatio)
    renderer.setSize(window.innerWidth, window.innerHeight)
    renderer.outputEncoding = THREE.sRGBEncoding
    document.body.appendChild(renderer.domElement)

    let animationIntervalId = null

    const settings = {
        depth: 5,
        color: '#00ff54',
        filled: false,
        shape: 'triangle',
        structureType: 'quadtree',
        bloomStrength: 0.6,
        bloomThreshold: 0,
        bloomRadius: 0,
        sides: 6,
        seed: 42,
        enableParticles: true,
        mutationRate: 0.1,
        animationInterval: 200,
        animationEnabled: false,
        duration: 250,
        presets: {},
        exportImage: () => {
            const width = renderer.domElement.width
            const height = renderer.domElement.height

            const renderTarget = new THREE.WebGLRenderTarget(width, height, {
                encoding: THREE.sRGBEncoding
            })

            const originalRenderTarget = renderer.getRenderTarget()

            composer.setPixelRatio(1);
            composer.setSize(width, height);
            composer.renderToScreen = false;
            composer.readBuffer = renderTarget;

            composer.render()

            const pixels = new Uint8Array(width * height * 4)
            renderer.readRenderTargetPixels(renderTarget, 0, 0, width, height, pixels)

            const canvas = document.createElement('canvas')
            canvas.width = width
            canvas.height = height
            const ctx = canvas.getContext('2d')
            const imageData = ctx.createImageData(width, height)

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4
                    const j = ((height - y - 1) * width + x) * 4
                    imageData.data[i] = pixels[j]
                    imageData.data[i + 1] = pixels[j + 1]
                    imageData.data[i + 2] = pixels[j + 2]
                    imageData.data[i + 3] = 255
                }
            }

            ctx.putImageData(imageData, 0, 0)

            const link = document.createElement('a')
            link.download = 'fractal_with_bloom.png'
            link.href = canvas.toDataURL()
            link.click()

            renderTarget.dispose()
            renderer.setRenderTarget(originalRenderTarget)
            composer.setPixelRatio(window.devicePixelRatio);
            composer.setSize(window.innerWidth, window.innerHeight);
            composer.renderToScreen = true;
            composer.readBuffer = composer.renderTarget2;
        },
        toggleFullscreen: () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen()
            } else {
                document.exitFullscreen()
            }
        },
        randomize: () => {
            settings.depth = Math.floor(Math.random() * 3) + 2
            settings.color = '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
            settings.filled = Math.random() > 0.5
            settings.shape = ['square', 'circle', 'triangle', 'polygon'][Math.floor(Math.random() * 4)]
            settings.sides = Math.floor(Math.random() * 10) + 3
            settings.seed = Math.floor(Math.random() * 1000)
            gui.updateDisplay();
            generate()
        },
        savePreset: () => {
            const name = prompt('Preset name:')
            if (name) settings.presets[name] = {...settings}
        },
        loadPreset: () => {
            const names = Object.keys(settings.presets)
            const name = prompt('Choose preset:\n' + names.join('\n'))
            if (name && settings.presets[name]) {
                Object.assign(settings, settings.presets[name])
                generate()
            }
        },
        toggleAnimation: () => {
            if (settings.animationEnabled) {
                animationIntervalId = setInterval(settings.randomize, settings.animationInterval)
            } else {
                clearInterval(animationIntervalId)
            }
        }
    }

    function randomSeed(seed) {
        let x = Math.sin(seed++) * 10000
        return x - Math.floor(x)
    }

    class Quad {
        constructor(x, y, size, depth) {
            this.x = x
            this.y = y
            this.size = size
            this.depth = depth
            this.children = []
            if (depth > 0 && randomSeed(settings.seed + x + y) > 0.3) {
                const half = size / 2
                for (let dx of [0, half]) {
                    for (let dy of [0, half]) {
                        this.children.push(new Quad(x + dx, y + dy, half, depth - 1))
                    }
                }
            }
        }

        getLeaves() {
            if (this.children.length === 0) return [this]
            return this.children.flatMap(c => c.getLeaves())
        }
    }

    class BinaryTree {
        constructor(x, y, size, depth) {
            this.x = x
            this.y = y
            this.size = size
            this.depth = depth
            this.children = []
            if (depth > 0 && randomSeed(settings.seed + x + y) > 0.4) {
                const half = size / 2
                this.children.push(new BinaryTree(x, y, half, depth - 1))
                this.children.push(new BinaryTree(x + half, y, half, depth - 1))
            }
        }

        getLeaves() {
            if (this.children.length === 0) return [this]
            return this.children.flatMap(c => c.getLeaves())
        }
    }

    function createPolygonGeometry(sides, radius) {
        return new THREE.CircleGeometry(radius, sides)
    }

    function addParticles(x, y) {
        const geometry = new THREE.BufferGeometry()
        const vertices = []
        for (let i = 0; i < 50; i++) {
            vertices.push(x, y, 0)
        }
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3))
        const material = new THREE.PointsMaterial({color: settings.color, size: 2})
        const points = new THREE.Points(geometry, material)
        scene.add(points)
        anime({targets: points.material, opacity: [0, 1], duration: settings.duration, easing: 'easeOutQuad'})
    }

    function mutateSettings() {
        if (Math.random() < settings.mutationRate) settings.depth = Math.max(1, settings.depth + (Math.random() > 0.5 ? 1 : -1))
        if (Math.random() < settings.mutationRate) settings.seed = Math.floor(Math.random() * 1000)
        if (Math.random() < settings.mutationRate) settings.color = '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0')
    }

    function createShape(x, y, size, depth) {
        let geometry
        if (settings.shape === 'square') geometry = new THREE.PlaneGeometry(size, size)
        else if (settings.shape === 'circle') geometry = new THREE.CircleGeometry(size / 2, 32)
        else if (settings.shape === 'triangle') geometry = new THREE.CircleGeometry(size / 2, 3)
        else if (settings.shape === 'polygon') geometry = createPolygonGeometry(settings.sides, size / 2)

        const group = new THREE.Group()
        group.position.set(x + size / 2 - 500, y + size / 2 - 500, 0)
        group.scale.set(0.1, 0.1, 0.1)
        scene.add(group)

        const color = new THREE.Color(settings.color)
        color.offsetHSL(0, 0, -depth * 0.1)

        if (settings.filled) {
            const material = new THREE.MeshBasicMaterial({color, transparent: true, opacity: 0})
            const mesh = new THREE.Mesh(geometry, material)
            group.add(mesh)
            const edgeGeometry = new THREE.EdgesGeometry(geometry)
            const edgeMaterial = new THREE.LineBasicMaterial({color: 0x000000, transparent: true, opacity: 0})
            const edge = new THREE.LineSegments(edgeGeometry, edgeMaterial)
            group.add(edge)
            anime({
                targets: group.scale,
                x: 1,
                y: 1,
                z: 1,
                duration: settings.duration,
                easing: 'easeOutElastic(1, .5)'
            })
            anime({targets: mesh.material, opacity: 1, duration: settings.duration, easing: 'easeOutQuad'})
            anime({targets: edge.material, opacity: 1, duration: settings.duration, easing: 'easeOutQuad'})
        } else {
            const edges = new THREE.EdgesGeometry(geometry)
            const material = new THREE.LineBasicMaterial({color, transparent: true, opacity: 0})
            const mesh = new THREE.LineSegments(edges, material)
            group.add(mesh)
            anime({
                targets: group.scale,
                x: 1,
                y: 1,
                z: 1,
                duration: settings.duration,
                easing: 'easeOutElastic(1, .5)'
            })
            anime({targets: mesh.material, opacity: 1, duration: settings.duration, easing: 'easeOutQuad'})
        }

        if (settings.enableParticles) addParticles(group.position.x, group.position.y)
    }

    function generate() {
        while (scene.children.length > 0) scene.remove(scene.children[0])
        mutateSettings()
        const Structure = settings.structureType === 'binary' ? BinaryTree : Quad
        const root = new Structure(0, 0, 1000, settings.depth)
        const leaves = root.getLeaves()
        leaves.forEach(q => createShape(q.x, q.y, q.size, q.depth))
    }

    function updateMaterial() {
        scene.traverse(obj => {
            if (obj.isMesh || obj.isLineSegments) {
                if (obj.material && obj.material.color) obj.material.color.set(settings.color)
            }
        })
    }

    function onWindowResize() {
        const width = window.innerWidth
        const height = window.innerHeight
        renderer.setSize(width, height)
        composer.setSize(width, height)
        const aspectRatio = width / height
        const gridSize = 1000
        const padding = 1.2
        let halfWidth, halfHeight
        if (aspectRatio >= 1) {
            halfHeight = (gridSize / 2) * padding
            halfWidth = halfHeight * aspectRatio
        } else {
            halfWidth = (gridSize / 2) * padding
            halfHeight = halfWidth / aspectRatio
        }
        camera.left = -halfWidth
        camera.right = halfWidth
        camera.top = halfHeight
        camera.bottom = -halfHeight
        camera.updateProjectionMatrix()
    }

    const composer = new EffectComposer(renderer)
    const renderPass = new RenderPass(scene, camera)
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), settings.bloomStrength, settings.bloomRadius, settings.bloomThreshold)
    composer.addPass(renderPass)
    composer.addPass(bloomPass)

    const gui = new GUI()
    const folder = gui.addFolder('Fractal')
    folder.add(settings, 'depth', 1, 4, 0.05).onChange(generate)
    folder.addColor(settings, 'color').onChange(updateMaterial)
    folder.add(settings, 'filled').onChange(generate)
    folder.add(settings, 'shape', ['square', 'circle', 'triangle', 'polygon']).onChange(generate)
    folder.add(settings, 'sides', 3, 12, 1).onChange(generate).name('polygon sides')
    folder.add(settings, 'seed', 0, 1000, 1).onChange(generate)
    folder.add(settings, 'structureType', ['quadtree', 'binary']).onChange(generate)
    folder.add(settings, 'enableParticles').onChange(generate)
    folder.add(settings, 'mutationRate', 0, 1, 0.01)

    const bloomFolder = gui.addFolder('Bloom')
    bloomFolder.add(settings, 'bloomStrength', 0, 3).onChange(() => bloomPass.strength = settings.bloomStrength)
    bloomFolder.add(settings, 'bloomThreshold', 0, 1).onChange(() => bloomPass.threshold = settings.bloomThreshold)
    bloomFolder.add(settings, 'bloomRadius', 0, 1).onChange(() => bloomPass.radius = settings.bloomRadius)

    const animationFolder = gui.addFolder('Animation');
    animationFolder.add(settings, 'animationEnabled').name('Enable Animation').onChange(settings.toggleAnimation);
    animationFolder.add(settings, 'animationInterval', 100, 5000, 50).name('Interval (ms)').onChange(() => {
        if (settings.animationEnabled) {
            clearInterval(animationIntervalId);
            animationIntervalId = setInterval(settings.randomize, settings.animationInterval);
        }
    });

    const actionFolder = gui.addFolder('Action')
    actionFolder.add(settings, 'exportImage').name('Export Image')
    actionFolder.add(settings, 'toggleFullscreen').name('Fullscreen')
    actionFolder.add(settings, 'randomize').name('Randomize')
    actionFolder.add(settings, 'savePreset').name('Save Preset')
    actionFolder.add(settings, 'loadPreset').name('Load Preset')


    gui.close()

    onWindowResize()
    window.addEventListener('resize', onWindowResize)
    // document.body.addEventListener('dblclick', generate)
    document.body.addEventListener('dblclick', settings.randomize)

    function animate() {
        requestAnimationFrame(animate)
        composer.render()
    }

    generate()
    animate()
</script>
</body>
</html>