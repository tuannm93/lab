<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Febrile Incantation â€” Geometrical Deities</title>

    <style>
        :root {
            --bg: #06060a;
            --panel: rgba(255, 255, 255, 0.06);
            --accent: #ff66cc;
            --muted: rgba(255, 255, 255, 0.6);
        }

        html, body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            font-family: Inter, ui-sans-serif, system-ui, Segoe UI, Roboto, 'Helvetica Neue', Arial
        }

        .wrap {
            display: grid;
            grid-template-columns:1fr 340px;
            gap: 16px;
            height: 100vh;
            padding: 18px;
            box-sizing: border-box
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 12px;
            box-shadow: 0 6px 30px rgba(0, 0, 0, 0.6);
            background: linear-gradient(180deg, #03030a 0%, #060616 100%)
        }

        .panel {
            background: var(--panel);
            backdrop-filter: blur(6px);
            padding: 14px;
            border-radius: 12px;
            color: white
        }

        h1 {
            margin: 0 0 8px 0;
            font-size: 18px
        }

        label {
            display: block;
            font-size: 13px;
            color: var(--muted);
            margin-top: 10px
        }

        input[type=range] {
            width: 100%
        }

        .small {
            font-size: 12px;
            color: var(--muted);
            margin-top: 8px
        }

        .footer {
            margin-top: 12px;
            font-size: 12px;
            color: var(--muted)
        }

        .btn {
            display: inline-block;
            margin-top: 10px;
            padding: 8px 12px;
            border-radius: 8px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.08);
            cursor: pointer;
            color: var(--muted)
        }

        .credits {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.45);
            margin-top: 10px
        }

        .legend {
            font-family: monospace;
            font-size: 12px;
            color: #d8cfe8;
            white-space: pre-wrap;
            margin-top: 10px
        }
    </style>
</head>
<body>
<div class="wrap">
    <div>
        <canvas id="c"></canvas>
    </div>
    <aside class="panel">
        <h1>Febrile Incantation</h1>
        <div class="small">An audiovisual playground that renders a swirling "incantation" of geometric particles based
            on the expression you supplied.
        </div>

        <label>Particle count: <span id="countVal">800</span></label>
        <input id="count" max="2500" min="50" type="range" value="800">

        <label>Speed multiplier: <span id="speedVal">1.00</span></label>
        <input id="speed" max="3" min="0" step="0.01" type="range" value="1">

        <label>Chaos (r amplitude): <span id="rVal">0.70</span></label>
        <input id="ramp" max="2" min="0" step="0.01" type="range" value="0.7">

        <label>Trail fade: <span id="fadeVal">0.08</span></label>
        <input id="fade" max="0.5" min="0.01" step="0.01" type="range" value="0.08">

        <button class="btn" id="pause">Pause</button>
        <button class="btn" id="reset">Reset</button>

        <div class="legend">
            Expression snippet used (interpreted):
            circle(x += cos(a = bezierTangent(0, d, sin(d)*9, sin(t+e), e*sin(t+e*5)) + r)*3,
            y += sin(a)*3,
            e*e*6)
        </div>

        <div class="credits">Tip: resize the window for different compositions. Use darker/lighter backgrounds by
            editing CSS at the top.
        </div>
    </aside>
</div>

<script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    let W = 0, H = 0, anim = true, last = 0;

    function resize() {
        W = canvas.width = canvas.clientWidth * devicePixelRatio;
        H = canvas.height = canvas.clientHeight * devicePixelRatio;
        ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
    }

    window.addEventListener('resize', resize);
    resize();

    // UI
    const countSlider = document.getElementById('count');
    const speedSlider = document.getElementById('speed');
    const rAmpSlider = document.getElementById('ramp');
    const fadeSlider = document.getElementById('fade');
    const pauseBtn = document.getElementById('pause');
    const resetBtn = document.getElementById('reset');
    const countVal = document.getElementById('countVal');
    const speedVal = document.getElementById('speedVal');
    const rVal = document.getElementById('rVal');
    const fadeVal = document.getElementById('fadeVal');

    let PARTICLES = parseInt(countSlider.value, 10);
    let SPEED = parseFloat(speedSlider.value);
    let RAMP = parseFloat(rAmpSlider.value);
    let FADE = parseFloat(fadeSlider.value);

    countSlider.oninput = () => {
        PARTICLES = parseInt(countSlider.value, 10);
        countVal.textContent = PARTICLES;
        initParticles();
    }
    speedSlider.oninput = () => {
        SPEED = parseFloat(speedSlider.value);
        speedVal.textContent = SPEED.toFixed(2);
    }
    rAmpSlider.oninput = () => {
        RAMP = parseFloat(rAmpSlider.value);
        rVal.textContent = RAMP.toFixed(2);
    }
    fadeSlider.oninput = () => {
        FADE = parseFloat(fadeSlider.value);
        fadeVal.textContent = FADE.toFixed(2);
    }

    pauseBtn.onclick = () => {
        anim = !anim;
        pauseBtn.textContent = anim ? 'Pause' : 'Resume';
        if (anim) requestAnimationFrame(loop);
    }
    resetBtn.onclick = () => {
        initParticles();
        clearScreen();
    }

    // Utility: cubic bezier derivative at t (0..1) for control points p0..p3
    // returns angle in radians of the tangent vector
    function bezierTangent(t, p0, p1, p2, p3) {
        // Treat inputs as scalar y-values and compute dy/dx with implicit x = t axis. But user passed many scalars; to create a 2D tangent we'll craft a parametric bezier where x is t and y is the provided values.
        // For visual variety we'll interpret p0..p3 as y-values; x-values will be 0..1 evenly spaced. Compute dy/dx via derivative of cubic Bezier: B'(t) = 3(1-t)^2(P1-P0) + 6(1-t)t(P2-P1) + 3t^2(P3-P2)
        const dy = 3 * (1 - t) * (1 - t) * (p1 - p0) + 6 * (1 - t) * t * (p2 - p1) + 3 * t * t * (p3 - p2);
        const dx = 1; // because our x increases uniformly with parameter t
        return Math.atan2(dy, dx);
    }

    // Particle structure
    let particles = [];

    function rand(a, b) {
        return a + Math.random() * (b - a)
    }

    function initParticles() {
        particles = [];
        for (let i = 0; i < PARTICLES; i++) {
            const x = W / (2 * devicePixelRatio) + rand(-40, 40);
            const y = H / (2 * devicePixelRatio) + rand(-40, 40);
            const d = rand(-2, 2);
            const e = rand(0.02, 1.2);
            const r = rand(-RAMP, RAMP);
            const t = rand(0, Math.PI * 2);
            const hue = (i / PARTICLES) * 360;
            particles.push({x, y, d, e, r, t, hue});
        }
    }

    function clearScreen() {
        ctx.fillStyle = 'rgba(6,6,10,1)';
        ctx.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);
    }

    function loop(ts) {
        if (!last) last = ts;
        const dt = (ts - last) / 1000;
        last = ts;
        if (!anim) return;

        // fade with translucent rect (controls trail persistence)
        ctx.fillStyle = `rgba(6,6,10,${FADE})`;
        ctx.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);

        const time = performance.now() / 1000 * SPEED;

        for (let p of particles) {
            // interpret the expression: a = bezierTangent(0, d, sin(d)*9, sin(t+e), e*sin(t+e*5)) + r
            // then x += cos(a)*3, y += sin(a)*3, radius = e*e*6
            p.t += 0.005 * SPEED * (0.5 + Math.abs(Math.sin(p.e * 3 + time)) * 2);
            const tparam = (p.t % 1 + 1) % 1; // ensure 0..1
            const bez = bezierTangent(0, p.d, Math.sin(p.d) * 9, Math.sin(tparam + p.e + time), p.e * Math.sin(tparam + p.e * 5 + time));
            const a = bez + p.r;
            p.x += Math.cos(a) * 3;
            p.y += Math.sin(a) * 3;

            // wrap-around edges for continuous patterns
            const Wpx = canvas.clientWidth, Hpx = canvas.clientHeight;
            if (p.x < -50) p.x += Wpx + 100;
            if (p.y < -50) p.y += Hpx + 100;
            if (p.x > Wpx + 50) p.x -= Wpx + 100;
            if (p.y > Hpx + 50) p.y -= Hpx + 100;

            const radius = Math.max(0.2, Math.pow(p.e, 2) * 6);

            // color shifts based on angle and e
            const sat = Math.min(100, 30 + Math.abs(Math.sin(a)) * 70);
            const light = Math.min(70, 30 + p.e * 40 + Math.abs(Math.cos(p.t)) * 20);
            ctx.beginPath();
            ctx.fillStyle = `hsl(${(p.hue + Math.floor(time * 40)) % 360} ${sat}% ${light}%)`;
            ctx.globalAlpha = 0.9 * Math.min(1, 0.3 + p.e);
            ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
            ctx.fill();
        }

        // subtle vignette / additive glow
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = 0.06;
        // draw a radial subtle glow centered
        const g = ctx.createRadialGradient(canvas.clientWidth / 2, canvas.clientHeight / 2, 10, canvas.clientWidth / 2, canvas.clientHeight / 2, Math.max(canvas.clientWidth, canvas.clientHeight) / 1.1);
        g.addColorStop(0, 'rgba(255,255,255,0.02)');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);

        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = 'source-over';

        requestAnimationFrame(loop);
    }

    // initialize
    initParticles();
    clearScreen();
    requestAnimationFrame(loop);

    // ensure canvas pixel size correct when container size changes
    new ResizeObserver(resize).observe(canvas);
</script>
</body>
</html>