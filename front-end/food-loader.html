<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Food loader</title>

    <style>
        .loading-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .menu-btn {
            width: 48px;
            height: 48px;
            display: inline-grid;
            place-items: center;
            border: 0;
            border-radius: 12px;
            background: none;
            color: green;
            cursor: pointer;
            transform: scale(3.4)
        }

        /* keep your original svgs hidden (we read their paths) */
        .menu-btn > span {
            position: absolute;
            width: 0;
            height: 0;
            overflow: hidden;
        }

        /* visible morph canvas */
        .morph-svg {
            width: 36px;
            height: 36px;
            display: block;
        }

        .morph-path {
            fill: currentColor;
        }
    </style>
</head>
<body>
<div class="loading-container">
    <div class="menu-btn">
        <!-- HIDDEN ORIGINAL SHAPES (for path sampling) -->
        <span class="icon-burger-icon-fork">
    <svg height="36" viewBox="0 0 36 36" width="36">
      <style>.st0 {
          display: none
      }</style>
      <path d="M9.8,15l-8.3,0c-0.6,0-1,0.3-1,0.6c0,0.3,0.5,0.6,1,0.6h7.2v1.2H1.5c-0.6,0-1,0.3-1,0.6s0.5,0.6,1,0.6h7.2v1.2H1.5
        c-0.6,0-1,0.3-1,0.6c0,0.3,0.5,0.6,1,0.6h8.3c2.5,0,4.5-1,5-2.4h19.7c0.6,0,1-0.3,1-0.6s-0.5-0.6-1-0.6H14.8C14.3,16,12.3,15,9.8,15
        z"/>
    </svg>
  </span>

        <span class="icon-burger-icon-spoon">
    <svg height="36" viewBox="0 0 36 36" width="36">
      <style>.st0 {
          display: none
      }</style>
      <path d="M23.7,17.4H1.5c-0.6,0-1,0.3-1,0.6s0.5,0.6,1,0.6h22.1c0.6,1.4,2.5,2.4,6,2.4c4,0,5.8-1.3,5.8-3s-1.8-3-5.8-3
        C26.2,15,24.3,16,23.7,17.4z"/>
    </svg>
  </span>

        <span class="icon-burger-icon-knife">
    <svg height="36" viewBox="0 0 36 36" width="36">
      <style>.st0 {
          display: none
      }</style>
      <path d="M20.1,19.5h7.7c3.2,0,6.2-0.4,7.6-2.1c0.2-0.2,0.1-0.4,0-0.6c-0.2-0.2-0.5-0.3-0.9-0.3H1.5c-0.6,0-1,0.3-1,0.6
        c0,0.3,0.5,0.6,1,0.6H15C15.5,19.1,17.6,19.5,20.1,19.5z"/>
    </svg>
  </span>

        <!-- VISIBLE MORPHING ICON -->
        <svg aria-hidden="true" class="morph-svg" height="36" viewBox="0 0 36 36" width="36">
            <path class="morph-path" d=""></path>
        </svg>
    </div>
</div>

<script>
    (() => {
        const btn = document.querySelector('.menu-btn');
        const sources = [
            document.querySelector('.icon-burger-icon-fork svg path:not(.st0)'),
            document.querySelector('.icon-burger-icon-spoon svg path:not(.st0)'),
            document.querySelector('.icon-burger-icon-knife svg path:not(.st0)')
        ].filter(Boolean);

        const morphSvg = btn.querySelector('.morph-svg');
        const morphPath = morphSvg.querySelector('.morph-path');
        const VIEWBOX = [0, 0, 36, 36];
        const N_SAMPLES = 180;

        let idx = 0;
        let shapes = [];

        function samplePath(pathEl, n = N_SAMPLES) {
            const len = pathEl.getTotalLength();
            const pts = [];
            for (let i = 0; i < n; i++) {
                const p = pathEl.getPointAtLength((i / n) * len);
                pts.push([p.x, p.y]);
            }
            return pts;
        }

        function pointsToPath(points) {
            let d = `M ${points[0][0]} ${points[0][1]}`;
            for (let i = 1; i < points.length; i++) d += ` L ${points[i][0]} ${points[i][1]}`;
            return d + ' Z';
        }

        function bestRotate(a, b) {
            let bestK = 0, bestDist = Infinity;
            for (let k = 0; k < b.length; k++) {
                const dx = a[0][0] - b[k][0], dy = a[0][1] - b[k][1];
                const d2 = dx * dx + dy * dy;
                if (d2 < bestDist) {
                    bestDist = d2;
                    bestK = k;
                }
            }
            return b.slice(bestK).concat(b.slice(0, bestK));
        }

        const lerp = (a, b, t) => a + (b - a) * t;
        const ease = (t) => t < .5 ? 2 * t * t : 1 - (((-2 * t + 2) ** 2) / 2);

        function tween(a, b, t) {
            return a.map((p, i) => [lerp(p[0], b[i][0], t), lerp(p[1], b[i][1], t)]);
        }

        function animate(from, to, duration = 900) {
            let t0 = null;

            function frame(ts) {
                if (!t0) t0 = ts;
                const t = Math.min(1, (ts - t0) / duration);
                morphPath.setAttribute("d", pointsToPath(tween(from, to, ease(t))));
                if (t < 1) requestAnimationFrame(frame);
            }

            requestAnimationFrame(frame);
        }

        function init() {
            morphSvg.setAttribute('viewBox', VIEWBOX.join(' '));
            shapes = sources.map(p => samplePath(p, N_SAMPLES));
            morphPath.setAttribute('d', pointsToPath(shapes[0]));
        }

        init();

        //----------------------------
        // CONTINUOUS LOOP
        //----------------------------
        function cycle() {
            const from = shapes[idx];
            const next = (idx + 1) % shapes.length;
            let to = bestRotate(from, shapes[next]);
            animate(from, to, 900);
            idx = next;
            setTimeout(cycle, 1200); // adjust pause length here
        }

        setTimeout(cycle, 400);
    })();
</script>
</body>
</html>