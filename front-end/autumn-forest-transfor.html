<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Autumn Forest Transfor</title>

    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: "Arial", sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            min-height: 100vh;
            color: white;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            text-align: center;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 2rem;
            color: #f0f0f0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .canvas-container {
            position: relative;
            display: inline-block;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 2rem;
        }

        #forestCanvas {
            border-radius: 15px;
            display: block;
            max-width: 100%;
            height: auto;
        }

        .controls {
            margin: 2rem 0;
        }

        .controls button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            color: white;
            padding: 12px 24px;
            margin: 0 10px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .controls button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .controls button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .progress {
            width: 300px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            margin: 1rem auto;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #22c55e, #eab308, #ef4444);
            border-radius: 4px;
            width: 0%;
            transition: width 0.3s ease;
        }

        .info {
            font-size: 1.1rem;
            color: #c0c0e0;
            margin-top: 1.5rem;
            line-height: 1.5;
        }

        .debug-info {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            margin-top: 1rem;
            font-size: 0.9rem;
            color: #a0a0a0;
        }

    </style>
</head>
<body>
<div class="container">
    <h1>Autumn Forest Transformation</h1>
    <div class="canvas-container">
        <canvas height="600" id="forestCanvas" width="800"></canvas>
    </div>
    <div class="controls">
        <button id="startAnimation">Start Fall Animation</button>
        <button id="resetAnimation">Reset to Summer</button>
        <div class="progress">
            <div class="progress-bar" id="progressBar"></div>
        </div>
    </div>
    <p class="info">12-second autumn transformation with TRUE vibrant reds</p>
</div>

<script>
    class VibrantRedLeafDetector {
        constructor(canvasId, imageUrl) {
            this.canvas = document.getElementById(canvasId);
            this.ctx = this.canvas.getContext("2d");
            this.imageUrl = imageUrl;

            this.leafPixels = new Map();
            this.originalImage = null;
            this.originalImageData = null;
            this.isAnimating = false;
            this.animationProgress = 0;
            this.debugInfo = document.createElement("div");
            this.debugInfo.className = "debug-info";

            this.overlayIntensity = 0.65;
            this.colorBlendStrength = 0.75;

            this.init();
        }

        async init() {
            try {
                await this.loadImage();
                this.detectLeaves();
                this.setupControls();
                this.showDebugInfo();
                console.log("Vibrant red leaf detector initialized successfully");
            } catch (error) {
                console.error("Failed to initialize:", error);
                this.showError(error.message);
            }
        }

        loadImage() {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = "anonymous";

                img.onload = () => {
                    console.log("Image loaded successfully:", img.width, "x", img.height);
                    this.originalImage = img;

                    const maxWidth = 800;
                    const maxHeight = 600;
                    const aspectRatio = img.width / img.height;

                    if (img.width > maxWidth || img.height > maxHeight) {
                        if (aspectRatio > maxWidth / maxHeight) {
                            this.canvas.width = maxWidth;
                            this.canvas.height = maxWidth / aspectRatio;
                        } else {
                            this.canvas.height = maxHeight;
                            this.canvas.width = maxHeight * aspectRatio;
                        }
                    } else {
                        this.canvas.width = img.width;
                        this.canvas.height = img.height;
                    }

                    this.ctx.drawImage(img, 0, 0, this.canvas.width, this.canvas.height);

                    try {
                        this.originalImageData = this.ctx.getImageData(
                            0,
                            0,
                            this.canvas.width,
                            this.canvas.height
                        );
                        resolve();
                    } catch (err) {
                        reject(new Error("Cannot access image pixel data: " + err.message));
                    }
                };

                img.onerror = (error) => {
                    console.error("Failed to load image:", error);
                    reject(new Error("Image loading failed"));
                };

                img.src = this.imageUrl;
            });
        }

        detectLeaves() {
            if (!this.originalImageData) {
                console.log("No image data available for leaf detection");
                return;
            }

            const pixels = this.originalImageData.data;
            console.log("Analyzing", pixels.length / 4, "pixels for leaf detection...");

            let leafCount = 0;
            let totalPixels = pixels.length / 4;

            for (let i = 0; i < pixels.length; i += 4) {
                const r = pixels[i];
                const g = pixels[i + 1];
                const b = pixels[i + 2];
                const a = pixels[i + 3];

                if (a < 128) continue;

                const hsv = this.rgbToHsv(r, g, b);

                if (this.isLeafPixel(hsv, r, g, b)) {
                    const pixelIndex = i / 4;
                    const x = pixelIndex % this.canvas.width;
                    const y = Math.floor(pixelIndex / this.canvas.width);

                    this.leafPixels.set(i, {
                        originalRgb: [r, g, b],
                        originalHsv: hsv,
                        x: x,
                        y: y,
                        leafIntensity: this.calculateLeafIntensity(hsv, r, g, b)
                    });
                    leafCount++;
                }
            }

            const percentage = ((leafCount / totalPixels) * 100).toFixed(2);
            console.log(`Detected ${leafCount} leaf pixels (${percentage}% of image)`);
        }

        isLeafPixel(hsv, r, g, b) {
            const [h, s, v] = hsv;

            const isHealthyGreen = h >= 75 && h <= 150 && s > 0.2 && v > 0.2;
            const isLightGreen = h >= 65 && h <= 85 && s > 0.15 && v > 0.4;
            const isDarkGreen = h >= 85 && h <= 120 && s > 0.25 && v > 0.15 && v < 0.7;

            const greenDominance = g > Math.max(r, b) && g > 60;
            const strongGreenDominance = g > (r + b) / 2 && g > 80;

            const greenness = (g - Math.max(r, b)) / 255;
            const isNaturalGreen = greenness > 0.08;

            const notTooLight = v < 0.95;
            const notTooDark = v > 0.08;
            const sufficientSaturation = s > 0.12;

            return (
                (isHealthyGreen ||
                    isLightGreen ||
                    isDarkGreen ||
                    (greenDominance && sufficientSaturation) ||
                    strongGreenDominance) &&
                isNaturalGreen &&
                notTooLight &&
                notTooDark
            );
        }

        calculateLeafIntensity(hsv, r, g, b) {
            const [h, s, v] = hsv;
            const greenness = (g - Math.max(r, b)) / 255;

            const saturationWeight = s * 0.4;
            const valueWeight = Math.min(v, 0.8) * 0.3;
            const greennessWeight = Math.min(greenness, 1) * 0.3;

            return Math.min(saturationWeight + valueWeight + greennessWeight, 1);
        }

        rgbToHsv(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const diff = max - min;

            let h = 0;
            if (diff !== 0) {
                if (max === r) h = ((g - b) / diff) % 6;
                else if (max === g) h = (b - r) / diff + 2;
                else h = (r - g) / diff + 4;
            }
            h = Math.round(h * 60);
            if (h < 0) h += 360;

            const s = max === 0 ? 0 : diff / max;
            const v = max;

            return [h, s, v];
        }

        hsvToRgb(h, s, v) {
            const c = v * s;
            const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
            const m = v - c;

            let r, g, b;
            if (h >= 0 && h < 60) [r, g, b] = [c, x, 0];
            else if (h >= 60 && h < 120) [r, g, b] = [x, c, 0];
            else if (h >= 120 && h < 180) [r, g, b] = [0, c, x];
            else if (h >= 180 && h < 240) [r, g, b] = [0, x, c];
            else if (h >= 240 && h < 300) [r, g, b] = [x, 0, c];
            else [r, g, b] = [c, 0, x];

            return [
                Math.round((r + m) * 255),
                Math.round((g + m) * 255),
                Math.round((b + m) * 255)
            ];
        }

        animateFall() {
            if (!this.isAnimating) return;

            const duration = 12000;
            const startTime = performance.now();

            const animate = (currentTime) => {
                if (!this.isAnimating) return;

                const elapsed = currentTime - startTime;
                this.animationProgress = Math.min(elapsed / duration, 1);

                const progressBar = document.getElementById("progressBar");
                if (progressBar) {
                    progressBar.style.width = this.animationProgress * 100 + "%";
                }

                this.updateLeafColors();

                if (this.animationProgress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    this.isAnimating = false;
                    const startBtn = document.getElementById("startAnimation");
                    if (startBtn) {
                        startBtn.textContent = "Start Fall Animation";
                        startBtn.disabled = false;
                    }
                }
            };

            requestAnimationFrame(animate);
        }

        updateLeafColors() {
            if (this.originalImageData) {
                this.ctx.putImageData(this.originalImageData, 0, 0);
            }

            const imageData = this.ctx.getImageData(
                0,
                0,
                this.canvas.width,
                this.canvas.height
            );
            const pixels = imageData.data;

            for (const [pixelIndex, leafData] of this.leafPixels) {
                const originalRgb = leafData.originalRgb;
                const fallColor = this.calculateTrueVibrantFallColor(
                    leafData.originalHsv,
                    this.animationProgress,
                    leafData.leafIntensity
                );

                const blendAmount =
                    this.colorBlendStrength * Math.pow(this.animationProgress, 0.8);
                const blendedColor = this.blendColors(
                    originalRgb,
                    fallColor,
                    blendAmount
                );

                pixels[pixelIndex] = blendedColor[0];
                pixels[pixelIndex + 1] = blendedColor[1];
                pixels[pixelIndex + 2] = blendedColor[2];
            }

            this.ctx.putImageData(imageData, 0, 0);
        }

        blendColors(originalRgb, newRgb, blendAmount) {
            const [origR, origG, origB] = originalRgb;
            const [newR, newG, newB] = newRgb;

            const blendedR = Math.round(origR * (1 - blendAmount) + newR * blendAmount);
            const blendedG = Math.round(origG * (1 - blendAmount) + newG * blendAmount);
            const blendedB = Math.round(origB * (1 - blendAmount) + newB * blendAmount);

            return [blendedR, blendedG, blendedB];
        }

        calculateTrueVibrantFallColor(originalHsv, progress, intensity = 1) {
            const [originalH, originalS, originalV] = originalHsv;

            let newH, newS, newV;

            const adjustedProgress = Math.min(progress * (0.9 + intensity * 0.2), 1);

            if (adjustedProgress < 0.2) {
                // Early fall: Bright yellowing
                newH = originalH + (65 - originalH) * (adjustedProgress / 0.2) * 0.7;
                newS = Math.min(originalS + 0.2, 0.9);
                newV = Math.min(originalV + 0.15, 0.95);
            } else if (adjustedProgress < 0.4) {
                // Mid-early fall: Yellow to bright yellow-orange
                const localProgress = (adjustedProgress - 0.2) / 0.2;
                newH = 65 - 20 * localProgress; // 65 to 45 (bright yellow-orange)
                newS = 0.85 + 0.1 * localProgress; // High saturation
                newV = 0.9 - 0.05 * localProgress; // Keep bright
            } else if (adjustedProgress < 0.7) {
                // Mid fall: Orange to bright red-orange
                const localProgress = (adjustedProgress - 0.4) / 0.3;
                newH = 45 - 30 * localProgress; // 45 to 15 (red-orange)
                newS = 0.95; // Maximum saturation for vibrancy
                newV = 0.85 + 0.05 * localProgress; // Slightly brighter
            } else {
                // Late fall: TRUE VIBRANT REDS
                const localProgress = (adjustedProgress - 0.7) / 0.3;

                newH = 15 - 12 * localProgress; // 15 to 3 (pure red range)

                // *** MAXIMUM SATURATION AND HIGH BRIGHTNESS ***
                newS = 0.95 + 0.05 * (1 - localProgress); // Stay at peak saturation
                newV = 0.8 + 0.1 * (1 - localProgress); // Bright, not dark

                // Add some variety between crimson and scarlet reds
                if (Math.random() > 0.5) {
                    newH = Math.max(0, newH - 3); // Some pure reds (hue 0-3)
                    newS = 1.0; // Maximum saturation
                    newV = 0.85 + Math.random() * 0.1; // 85-95% brightness
                }
            }

            // Reduced variation to maintain vibrant reds
            const variation = 0.03 * intensity;
            newH += (Math.random() - 0.5) * variation * 20; // Much smaller hue variation
            newS += (Math.random() - 0.5) * variation * 0.1; // Minimal saturation variation
            newV += (Math.random() - 0.5) * variation * 0.05; // Minimal brightness variation

            // *** CRITICAL: Clamp to ensure vibrant reds ***
            newH = Math.max(0, Math.min(20, newH)); // Keep in red-orange range
            newS = Math.max(0.8, Math.min(1.0, newS)); // Minimum 80% saturation
            newV = Math.max(0.7, Math.min(0.95, newV)); // Keep bright (70-95%)

            return this.hsvToRgb(newH, newS, newV);
        }

        showDebugInfo() {
            const leafCount = this.leafPixels.size;
            const totalPixels = this.canvas.width * this.canvas.height;
            const percentage = ((leafCount / totalPixels) * 100).toFixed(2);

            this.debugInfo.innerHTML = `
      <strong>Detection Results:</strong><br>
      Image Size: ${this.canvas.width}×${this.canvas.height}<br>
      Leaf Pixels Detected: ${leafCount.toLocaleString()} (${percentage}%)<br>
      Animation Duration: 12 seconds<br>
      Color Style: TRUE VIBRANT REDS (Fixed!)<br>
      Red Hue Range: 0-20° (pure red zone)<br>
      Red Saturation: 80-100% (no muddy browns)<br>
      Ready for brilliant autumn transformation!
    `;

            const container = document.querySelector(".container");
            container.appendChild(this.debugInfo);
        }

        showError(message) {
            this.debugInfo.innerHTML = `<strong>Error:</strong> ${message}`;
            this.debugInfo.style.color = "#ff6b6b";
            const container = document.querySelector(".container");
            container.appendChild(this.debugInfo);
        }

        setupControls() {
            const startBtn = document.getElementById("startAnimation");
            const resetBtn = document.getElementById("resetAnimation");

            if (startBtn) {
                startBtn.addEventListener("click", () => {
                    if (!this.isAnimating && this.leafPixels.size > 0) {
                        this.isAnimating = true;
                        this.animationProgress = 0;
                        this.animateFall();
                        startBtn.textContent = "Animation Running...";
                        startBtn.disabled = true;

                        setTimeout(() => {
                            if (startBtn) {
                                startBtn.textContent = "Start Fall Animation";
                                startBtn.disabled = false;
                            }
                        }, 12000);
                    }
                });
            }

            if (resetBtn) {
                resetBtn.addEventListener("click", () => {
                    this.isAnimating = false;
                    this.animationProgress = 0;

                    if (this.originalImageData) {
                        this.ctx.putImageData(this.originalImageData, 0, 0);
                    }

                    const progressBar = document.getElementById("progressBar");
                    if (progressBar) progressBar.style.width = "0%";

                    const startBtn = document.getElementById("startAnimation");
                    if (startBtn) {
                        startBtn.textContent = "Start Fall Animation";
                        startBtn.disabled = false;
                    }
                });
            }
        }
    }

    // Initialize leaf image
    document.addEventListener("DOMContentLoaded", () => {
        const detector = new VibrantRedLeafDetector(
            "forestCanvas",
            "https://assets.codepen.io/11213919/tree-leaves.png"
        );
    });

</script>
</body>
</html>