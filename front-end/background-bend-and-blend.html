<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Background - Bend and blend</title>
    <style>
        body{
            overflow: hidden;
            margin: 0;
        }
    </style>
</head>
<body>
<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.180.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.180.0/examples/jsm/"
      }
    }
</script>
<script>
    const noise = `//	Simplex 3D Noise
//	by Ian McEwan, Stefan Gustavson (https://github.com/stegu/webgl-noise)
//
vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}

float snoise(vec3 v){
  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

// First corner
  vec3 i  = floor(v + dot(v, C.yyy) );
  vec3 x0 =   v - i + dot(i, C.xxx) ;

// Other corners
  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min( g.xyz, l.zxy );
  vec3 i2 = max( g.xyz, l.zxy );

  //  x0 = x0 - 0. + 0.0 * C
  vec3 x1 = x0 - i1 + 1.0 * C.xxx;
  vec3 x2 = x0 - i2 + 2.0 * C.xxx;
  vec3 x3 = x0 - 1. + 3.0 * C.xxx;

// Permutations
  i = mod(i, 289.0 );
  vec4 p = permute( permute( permute(
             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

// Gradients
// ( N*N points uniformly over a square, mapped onto an octahedron.)
  float n_ = 1.0/7.0; // N=7
  vec3  ns = n_ * D.wyz - D.xzx;

  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)

  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

  vec4 x = x_ *ns.x + ns.yyyy;
  vec4 y = y_ *ns.x + ns.yyyy;
  vec4 h = 1.0 - abs(x) - abs(y);

  vec4 b0 = vec4( x.xy, y.xy );
  vec4 b1 = vec4( x.zw, y.zw );

  vec4 s0 = floor(b0)*2.0 + 1.0;
  vec4 s1 = floor(b1)*2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));

  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

  vec3 p0 = vec3(a0.xy,h.x);
  vec3 p1 = vec3(a0.zw,h.y);
  vec3 p2 = vec3(a1.xy,h.z);
  vec3 p3 = vec3(a1.zw,h.w);

//Normalise gradients
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;

// Mix final noise value
  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
  m = m * m;
  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                dot(p2,x2), dot(p3,x3) ) );
}`;
</script>

<script type="module">
    import * as THREE from "three";
    import {OrbitControls} from "three/addons/controls/OrbitControls.js";

    console.clear();

    // load fonts
    await (async function () {
        async function loadFont(fontface) {
            await fontface.load();
            document.fonts.add(fontface);
        }

        let fonts = [
            new FontFace(
                "LibreBarcode128Text",
                "url(https://fonts.gstatic.com/s/librebarcode128text/v29/fdNv9tubt3ZEnz1Gu3I4-zppwZ9CWZ16Z0w5QVrS6Q.woff2) format('woff2')"
            )
        ];
        for (let font in fonts) {
            await loadFont(fonts[font]);
        }
    })();

    class Background extends THREE.WebGLRenderTarget {
        constructor() {
            super(innerWidth, innerHeight);

            const palette = [
                "#f72585",
                "#b5179e",
                "#7209b7",
                "#560bad",
                "#480ca8",
                "#3a0ca3",
                "#3f37c9",
                "#4361ee",
                "#4895ef",
                "#4cc9f0"
            ].reverse();


            this.camera = new THREE.Camera();
            this.scene = new THREE.Mesh(
                new THREE.PlaneGeometry(2, 2),
                new THREE.MeshBasicMaterial({
                    //color: "red",
                    onBeforeCompile: shader => {
                        shader.uniforms.aspect = gu.aspect;
                        shader.uniforms.time = gu.time;
                        shader.uniforms.blobs = {
                            value: Array.from({length: palette.length}, (_, idx) => {
                                return {
                                    color: new THREE.Color(palette[idx]),
                                    positionPhase: Math.random() - 0.5,
                                    positionSpeed: Math.random() * 0.4 + 0.1,
                                    positionRatio: new THREE.Vector2(Math.random() * 0.4 + 0.1, Math.random() * 0.4 + 0.1),
                                    maxRadius: Math.random() * 0.25 + 0.25,
                                    radiusPhase: Math.random()
                                }
                            })
                        }
                        shader.fragmentShader = `
            struct BlobData {
              vec3 color;
              float positionPhase;
              float positionSpeed;
              vec2 positionRatio;
              float maxRadius;
              float radiusPhase;
            };

            uniform float aspect;
            uniform float time;
            uniform BlobData[${palette.length}] blobs;

            ${noise}
            ${shader.fragmentShader}
          `.replace(
                            `#include <color_fragment>`,
                            `#include <color_fragment>

              float t = time * 0.5;

              vec3 col = mix(diffuseColor.rgb, blobs[7].color, 0.2);

              vec2 blobUV = (vUv - 0.5) * vec2(aspect, 1.);
              blobUV *= vec2(1., 4.);

              float vF = snoise(vec3(blobUV.x, blobUV.y, t * 0.25)) * 0.5;
              vF += snoise(vec3(blobUV.x, PI, t * 0.25));
              blobUV.y += vF;

              for(int i = 0; i < ${palette.length}; i++){
                BlobData blob = blobs[i];
                vec3 bColor = blob.color;

                float phaseSign = sign(blob.positionPhase);
                float speed = blob.positionSpeed;
                float phase = (blob.positionPhase + t * speed) * PI2 * phaseSign;
                vec2 posRatio = blob.positionRatio;
                vec2 center = vec2(cos(phase * posRatio.x), sin(phase * posRatio.y)) * 0.5 * blob.maxRadius;

                float dist = distance(blobUV, center);
                float distF = smoothstep(0., blob.maxRadius, dist);

                col = mix(bColor, col, distF);
              }

              diffuseColor.rgb = col;
            `
                        );
                        //console.log(shader.fragmentShader)
                    }
                })
            );
            this.scene.material.defines = {"USE_UV": ""};
        }

        render() {
            renderer.setRenderTarget(this);
            renderer.render(this.scene, this.camera);
            renderer.setRenderTarget(null);
        }
    }

    const gu = {
        time: {
            value: 0
        },
        aspect: {
            value: innerWidth / innerHeight
        }
    };
    const dpr = Math.min(devicePixelRatio, 1);
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 0.1, 100);
    camera.position.set(0, 0, 1).setLength(12);
    const renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setPixelRatio(devicePixelRatio);
    renderer.setSize(innerWidth * dpr, innerHeight * dpr);
    document.body.appendChild(renderer.domElement);

    window.addEventListener("resize", (event) => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth * dpr, innerHeight * dpr);
        bg.setSize(innerWidth * dpr, innerHeight * dpr);
        gu.aspect.value = camera.aspect;
    });

    let controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.autoRotate = true;
    controls.autoRotateSpeed *= 0.25;

    const light = new THREE.DirectionalLight(0xffffff, Math.PI * 1.75);
    light.position.set(0.5, 1, 1).setLength(50);
    scene.add(light, new THREE.AmbientLight(0xffffff, Math.PI * 0.25));

    const bg = new Background();
    scene.background = bg.texture;

    const thing = new THREE.InstancedMesh(
        new THREE.CylinderGeometry(1, 1, 1, 3, 1),
        new THREE.MeshPhysicalMaterial({
            side: THREE.DoubleSide,
            ior: 1.75,
            thickness: 5,
            metalness: 0,
            roughness: 0.75,
            opacity: 1,
            transmission: 1,
            dispersion: 5,
            onBeforeCompile: shader => {
                shader.uniforms.tex256 = {
                    value: (() => {
                        const c = document.createElement("canvas");
                        c.width = 2048;
                        c.height = 1024;
                        let u = (val) => val * c.height * 0.01;
                        const ctx = c.getContext("2d");

                        ctx.textAlign = "center";
                        ctx.textBaseline = 'middle';
                        ctx.font = `${u(95)}px LibreBarcode128Text`;
                        ctx.fillStyle = '#fff';
                        ctx.fillText("#849", c.width * 0.5, c.height * 0.5);

                        const tex = new THREE.CanvasTexture(c);
                        tex.anisotropy = renderer.capabilities.getMaxAnisotropy();

                        return tex;
                    })()
                };
                shader.vertexShader = `
        varying vec3 vPos;
        varying vec2 vUv;
        ${shader.vertexShader}
      `.replace(
                    `#include <begin_vertex>`,
                    `#include <begin_vertex>
          vPos = position;
          vUv = uv;
        `
                );
                shader.fragmentShader = `
        uniform sampler2D tex256;
        varying vec3 vPos;
        varying vec2 vUv;
        ${shader.fragmentShader}
      `.replace(
                    `#include <roughnessmap_fragment>`,
                    `#include <roughnessmap_fragment>

          float roughnessF = smoothstep(0.1, 0.16, abs(vPos.y));
          roughnessFactor *= roughnessF;

          vec2 texUV = (vUv - vec2(0., 0.5)) * vec2(3., 8.) + vec2(0., 0.5);
          texUV.x = fract(texUV.x);
          float texF = texture(tex256, texUV).r;

          roughnessFactor = max(roughnessFactor, texF);
        `
                );
            }
        }),
        15
    );
    const dummy = new THREE.Object3D();
    const color = new THREE.Color();
    for (let i = 0; i < thing.count; i++) {
        if (i != 0) {
            dummy.position.randomDirection().setLength(4);
            dummy.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            dummy.scale.set(0.75, Math.random() * 3 + 2, 0.75).multiplyScalar(0.5);
            color.setHSL(Math.random(), 0.75, 0.85);
        } else {
            dummy.scale.set(1, 7, 1);
            color.set(1, 1, 1);
        }
        dummy.updateMatrix();
        thing.setMatrixAt(i, dummy.matrix);

        thing.setColorAt(i, color);
    }
    scene.add(thing);

    const clock = new THREE.Clock();
    let t = 0;

    renderer.setAnimationLoop(() => {
        let dt = clock.getDelta();
        t += dt;
        gu.time.value = t;
        controls.update();
        bg.render();
        renderer.render(scene, camera);
    })

</script>
</body>
</html>